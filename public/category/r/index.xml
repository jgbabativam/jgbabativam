<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R | Giovany Babativa</title>
    <link>http://jgbabativam.rbind.io/category/r/</link>
      <atom:link href="http://jgbabativam.rbind.io/category/r/index.xml" rel="self" type="application/rss+xml" />
    <description>R</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>es</language><copyright>© 2020 Giovany Babativa-Márquez</copyright><lastBuildDate>Tue, 18 Apr 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>http://jgbabativam.rbind.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>R</title>
      <link>http://jgbabativam.rbind.io/category/r/</link>
    </image>
    
    <item>
      <title>Resumen y transformación de datos usando dplyr</title>
      <link>http://jgbabativam.rbind.io/post/data-wrangling/</link>
      <pubDate>Tue, 18 Apr 2023 00:00:00 +0000</pubDate>
      <guid>http://jgbabativam.rbind.io/post/data-wrangling/</guid>
      <description>


&lt;div id=&#34;introducción&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introducción&lt;/h2&gt;
&lt;p&gt;Suponga un conjunto de datos en formato ancho&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;datos &amp;lt;- tribble(
~&amp;quot;grupo&amp;quot;, ~ &amp;quot;Municipio&amp;quot;, ~&amp;quot;v_2017&amp;quot;, ~&amp;quot;v_2018&amp;quot;, ~&amp;quot;v_2019&amp;quot;, ~&amp;quot;v_2020&amp;quot;, ~&amp;quot;v_2021&amp;quot;,~&amp;quot;v_2022&amp;quot;,~&amp;quot;v_2023&amp;quot;,
       1,       &amp;quot;11001&amp;quot;,      53,      65,      74,      48,     67,     68,     79,
       1,       &amp;quot;05001&amp;quot;,      37,      49,      54,      61,     60,     59,     58,
       1,       &amp;quot;08001&amp;quot;,      25,      38,      45,      33,     36,     34,     33,
       1,       &amp;quot;76001&amp;quot;,      45,      52,      58,      49,     50,     55,     49,
       2,       &amp;quot;88001&amp;quot;,      15,      13,      17,      20,     25,     26,     28,
       2,       &amp;quot;63001&amp;quot;,      17,      25,      33,      48,     55,     58,     65,
       2,       &amp;quot;50001&amp;quot;,      21,      28,      42,      50,     52,     58,     60,
       2,       &amp;quot;23001&amp;quot;,      NA,       4,      NA,      25,     28,     35,     45
)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;resumen-de-múltiples-variables&#34; class=&#34;section level2 tabset&#34;&gt;
&lt;h2&gt;Resumen de múltiples variables&lt;/h2&gt;
&lt;p&gt;Cuando hablamos de depurar datos en R, también conocido como proceso de &lt;code&gt;data wrangling&lt;/code&gt;, uno de los paquetes más utilizados es &lt;code&gt;dplyr&lt;/code&gt;, incluido en el entorno &lt;code&gt;tidyverse&lt;/code&gt;. Estos procesos suelen ser los que más demandan tiempo dentro del ciclo de la analítica de los datos, y de ello depende en gran medida la calidad de los datos.&lt;/p&gt;
&lt;p&gt;Dentro de los verbos de &lt;code&gt;dplyr&lt;/code&gt; los comandos &lt;code&gt;starts_with(&#34;prefijo&#34;)&lt;/code&gt; permiten seleccionar las variables que inician con determinado patrón o &lt;code&gt;ends_with(&#34;sufijo&#34;)&lt;/code&gt; para las variables que finalizan con determinado patrón. Si buscamos resumir una gran cantidad de variables que comparten un prefijo o un sufijo, se pueden usar &lt;code&gt;summarise_at&lt;/code&gt; para afectar a un conjunto de variables o el comando &lt;code&gt;across&lt;/code&gt;&lt;/p&gt;
&lt;div id=&#34;usando-summarise_at&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Usando &lt;code&gt;summarise_at&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;En este caso se creará el objeto &lt;code&gt;res1&lt;/code&gt; que contiene la información de la media y la desviación estándar para todas las variables que inician con el prefijo &lt;code&gt;v_20&lt;/code&gt;, resumidas por la variable grupo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(res1 &amp;lt;- datos |&amp;gt;  
         group_by(grupo) |&amp;gt; 
         summarise_at(vars(starts_with(&amp;quot;v_20&amp;quot;)), 
                     list(media = ~mean(., na.rm = T), 
                          desv.est = ~sd(., na.rm = T)))) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 15
##   grupo v_2017_media v_2018_media v_2019_media v_2020_media v_2021_media
##   &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;
## 1     1         40           51           57.8         47.8         53.2
## 2     2         17.7         17.5         30.7         35.8         40  
## # ℹ 9 more variables: v_2022_media &amp;lt;dbl&amp;gt;, v_2023_media &amp;lt;dbl&amp;gt;,
## #   v_2017_desv.est &amp;lt;dbl&amp;gt;, v_2018_desv.est &amp;lt;dbl&amp;gt;, v_2019_desv.est &amp;lt;dbl&amp;gt;,
## #   v_2020_desv.est &amp;lt;dbl&amp;gt;, v_2021_desv.est &amp;lt;dbl&amp;gt;, v_2022_desv.est &amp;lt;dbl&amp;gt;,
## #   v_2023_desv.est &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;usando-across&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Usando &lt;code&gt;across&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;A diferencia del caso anterior, cuando se usa la función &lt;code&gt;across&lt;/code&gt;, se realiza sobre el verbo general &lt;code&gt;summarise()&lt;/code&gt;, el primer argumento indicará cuáles son las variables que se van a afectar, que en este caso corresponde a las variables con prefijo &lt;code&gt;v_20&lt;/code&gt;, para las cuales se calcula la media y desviación estándar por grupo. Hacerlo de esta forma evita el uso de verbos como &lt;code&gt;summarise_all()&lt;/code&gt;, &lt;code&gt;summarise_at()&lt;/code&gt; o &lt;code&gt;summarise_if()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;En este caso, también se le asignó a cada variable de resumen un nombre con el argumento &lt;code&gt;.names = &#34;{fn}_del_{col}&#34;&lt;/code&gt; que toma como prefijo el nombre asignado a la función (media o desv.est), separa con una barra al piso, seguido por la palabla &lt;em&gt;del&lt;/em&gt; y finaliza con el nombre de la variable original.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(res2 &amp;lt;- datos |&amp;gt;  
         group_by(grupo) |&amp;gt; 
         summarise(across(starts_with(&amp;quot;v_20&amp;quot;), 
                   list(media = ~mean(., na.rm = T), 
                        desv.est = ~sd(., na.rm = T)), 
                          .names = &amp;quot;{fn}_del_{col}&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 15
##   grupo media_del_v_2017 desv.est_del_v_2017 media_del_v_2018
##   &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;               &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;
## 1     1             40                 11.9              51  
## 2     2             17.7                3.06             17.5
## # ℹ 11 more variables: desv.est_del_v_2018 &amp;lt;dbl&amp;gt;, media_del_v_2019 &amp;lt;dbl&amp;gt;,
## #   desv.est_del_v_2019 &amp;lt;dbl&amp;gt;, media_del_v_2020 &amp;lt;dbl&amp;gt;,
## #   desv.est_del_v_2020 &amp;lt;dbl&amp;gt;, media_del_v_2021 &amp;lt;dbl&amp;gt;,
## #   desv.est_del_v_2021 &amp;lt;dbl&amp;gt;, media_del_v_2022 &amp;lt;dbl&amp;gt;,
## #   desv.est_del_v_2022 &amp;lt;dbl&amp;gt;, media_del_v_2023 &amp;lt;dbl&amp;gt;,
## #   desv.est_del_v_2023 &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;reubicación-de-variables&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Reubicación de variables&lt;/h2&gt;
&lt;p&gt;Es posible que quiera ordenar su conjunto de datos para dejar algunas variables al inicio o al final. Una posibilidad es usar el verbo &lt;code&gt;select()&lt;/code&gt; pero esto le implicaría indicar el orden de cada una de las variables, lo cual resulta tedioso. Una solución para este inconveniente es utilizar el verbo &lt;code&gt;relocate()&lt;/code&gt; listando las variables de interés y especificando un argumento &lt;code&gt;.before&lt;/code&gt; o &lt;code&gt;.after&lt;/code&gt; para indicar si las quiere antes o después de alguna variable específica.&lt;/p&gt;
&lt;p&gt;En el siguiente ejemplo se toma el conjunto de datos &lt;code&gt;res2&lt;/code&gt; obtenido previamente y las variables se reordenan colocando todas las medias en un primer bloque (luego de la variable grupo), de manera que las desviaciones estándar quedarán en un siguiente bloque.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(res3 &amp;lt;- res2 |&amp;gt; 
         relocate(starts_with(&amp;quot;media&amp;quot;), .after = grupo))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 15
##   grupo media_del_v_2017 media_del_v_2018 media_del_v_2019 media_del_v_2020
##   &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;
## 1     1             40               51               57.8             47.8
## 2     2             17.7             17.5             30.7             35.8
## # ℹ 10 more variables: media_del_v_2021 &amp;lt;dbl&amp;gt;, media_del_v_2022 &amp;lt;dbl&amp;gt;,
## #   media_del_v_2023 &amp;lt;dbl&amp;gt;, desv.est_del_v_2017 &amp;lt;dbl&amp;gt;,
## #   desv.est_del_v_2018 &amp;lt;dbl&amp;gt;, desv.est_del_v_2019 &amp;lt;dbl&amp;gt;,
## #   desv.est_del_v_2020 &amp;lt;dbl&amp;gt;, desv.est_del_v_2021 &amp;lt;dbl&amp;gt;,
## #   desv.est_del_v_2022 &amp;lt;dbl&amp;gt;, desv.est_del_v_2023 &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;resumen-de-estadísticas-por-filas&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Resumen de estadísticas por filas&lt;/h2&gt;
&lt;p&gt;En ocasiones deseamos obtener un resumen de las estadísticas para un conjunto de variables, en el caso del conjunto de datos de ejemplo podríamos estar interesados en calcular la media o la desviación estándar para cada municipio. Una manera de hacerlo con el adverbio&lt;code&gt;c_across&lt;/code&gt; una vez se ha especificado que los cálculos serán por fila usando el verbo &lt;code&gt;rowwise()&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;datos |&amp;gt; 
  rowwise() |&amp;gt; 
  dplyr::mutate(media = mean(c_across(starts_with(&amp;quot;v_20&amp;quot;)), na.rm = T))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 8 × 10
## # Rowwise: 
##   grupo Municipio v_2017 v_2018 v_2019 v_2020 v_2021 v_2022 v_2023 media
##   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1 11001         53     65     74     48     67     68     79  64.9
## 2     1 05001         37     49     54     61     60     59     58  54  
## 3     1 08001         25     38     45     33     36     34     33  34.9
## 4     1 76001         45     52     58     49     50     55     49  51.1
## 5     2 88001         15     13     17     20     25     26     28  20.6
## 6     2 63001         17     25     33     48     55     58     65  43  
## 7     2 50001         21     28     42     50     52     58     60  44.4
## 8     2 23001         NA      4     NA     25     28     35     45  27.4&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;reestructurar-a-lo-largo&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Reestructurar a lo largo&lt;/h2&gt;
&lt;p&gt;En ocasiones es útil dar una estructura larga al conjunto de datos, esto puede agilizar algunos procesos. En nuestro conjunto de datos cada municipio es una fila y los datos por año se encuentran en las columnas y posteriormente fue resumido con las estadísticas de la media y desviación estándar por grupo. Si nuestro propósito fuera generar una gráfica del comportamiento de cada grupo por año, esta estructura resultaría un poco compleja de manejar.&lt;/p&gt;
&lt;p&gt;En el siguiente ejemplo se usa &lt;code&gt;pivot_longer()&lt;/code&gt; para pivotear la tabla y ponerla hacía lo largo. En los argumentos se le indica que la columna &lt;em&gt;grupo&lt;/em&gt; es la única que no se afectará (&lt;em&gt;cols = -grupo&lt;/em&gt;), en el argumento &lt;code&gt;names_to&lt;/code&gt; se le ha indicado que vamos a crear dos columnas a partir del nombre de las variables de los datos originales, estas se denominarán &lt;em&gt;estadistica&lt;/em&gt; y &lt;em&gt;anio&lt;/em&gt;; ahora es necesario indicarle el patrón que tiene los nombres de las variables con el fin de que los pueda separar, así que el comando &lt;code&gt;names_pattern = &#34;(.*)_del_v_(.*)&#34;&lt;/code&gt; les está indicando que el patrón debe ser: tomar todo lo que está antes de “&lt;em&gt;del_v&lt;/em&gt;” y lo conservará en la columna &lt;em&gt;estadistica&lt;/em&gt;, mientras que todo lo que esté posterior a ese patrón lo conservará en la columna &lt;em&gt;anio&lt;/em&gt;. Los valores correspondientes se almancenan en la columna &lt;em&gt;valor&lt;/em&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(reesL &amp;lt;- res2 |&amp;gt;  
         pivot_longer(cols = -grupo, 
               names_to = c(&amp;quot;estadistica&amp;quot;, &amp;quot;anio&amp;quot;), 
               names_pattern = &amp;quot;(.*)_del_v_(.*)&amp;quot;, 
               values_to = &amp;quot;valor&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 28 × 4
##    grupo estadistica anio  valor
##    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
##  1     1 media       2017   40  
##  2     1 desv.est    2017   11.9
##  3     1 media       2018   51  
##  4     1 desv.est    2018   11.1
##  5     1 media       2019   57.8
##  6     1 desv.est    2019   12.1
##  7     1 media       2020   47.8
##  8     1 desv.est    2020   11.5
##  9     1 media       2021   53.2
## 10     1 desv.est    2021   13.5
## # ℹ 18 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora sería relativamente rápido hacer un gráfico de las medias&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;reesL |&amp;gt; 
  filter(estadistica == &amp;quot;media&amp;quot;) |&amp;gt; 
  mutate(grupo = factor(grupo, levels = 1:2, labels=c(&amp;quot;Grupo 1&amp;quot;, &amp;quot;grupo 2&amp;quot;))) |&amp;gt; 
  ggplot(aes(x = anio, y = valor, group = grupo, color = grupo, shape = grupo)) +
  geom_line() +
  geom_point() +
  labs(x = &amp;quot;Año&amp;quot;, y = &amp;quot;Promedio&amp;quot;) +
  theme_bw() +
  theme(legend.position = &amp;quot;bottom&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://jgbabativam.rbind.io/post/data-wrangling/index_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;reestructurar-a-lo-ancho&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Reestructurar a lo ancho&lt;/h2&gt;
&lt;p&gt;Es posible que la estructura anterio no sea de todo su agrado, y que prefiera tener una columna con la media y otra con la desviación estándar. Para ello, el conjunto se puede convertir a un formato ancho de la siguiente manera&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(reesA &amp;lt;- reesL |&amp;gt; 
         pivot_wider(names_from = estadistica,
                     values_from = valor))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 14 × 4
##    grupo anio  media desv.est
##    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
##  1     1 2017   40      11.9 
##  2     1 2018   51      11.1 
##  3     1 2019   57.8    12.1 
##  4     1 2020   47.8    11.5 
##  5     1 2021   53.2    13.5 
##  6     1 2022   54      14.4 
##  7     1 2023   54.8    19.2 
##  8     2 2017   17.7     3.06
##  9     2 2018   17.5    11.1 
## 10     2 2019   30.7    12.7 
## 11     2 2020   35.8    15.5 
## 12     2 2021   40      15.7 
## 13     2 2022   44.2    16.3 
## 14     2 2023   49.5    16.7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Otro ejemplo puede ser revertir el conjunto de datos largo y llevarlo a la estructura inicial, que se puede realizar de la siguiente forma&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(reesA2 &amp;lt;- reesL |&amp;gt; 
          pivot_wider(names_from = c(&amp;quot;estadistica&amp;quot;, &amp;quot;anio&amp;quot;),
                     values_from = valor))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 15
##   grupo media_2017 desv.est_2017 media_2018 desv.est_2018 media_2019
##   &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1     1       40           11.9        51            11.1       57.8
## 2     2       17.7          3.06       17.5          11.1       30.7
## # ℹ 9 more variables: desv.est_2019 &amp;lt;dbl&amp;gt;, media_2020 &amp;lt;dbl&amp;gt;,
## #   desv.est_2020 &amp;lt;dbl&amp;gt;, media_2021 &amp;lt;dbl&amp;gt;, desv.est_2021 &amp;lt;dbl&amp;gt;,
## #   media_2022 &amp;lt;dbl&amp;gt;, desv.est_2022 &amp;lt;dbl&amp;gt;, media_2023 &amp;lt;dbl&amp;gt;,
## #   desv.est_2023 &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Graficando funciones con ggplot2</title>
      <link>http://jgbabativam.rbind.io/post/2020-07-14-graficas-de-funciones-con-ggplot2/</link>
      <pubDate>Tue, 14 Jul 2020 00:00:00 +0000</pubDate>
      <guid>http://jgbabativam.rbind.io/post/2020-07-14-graficas-de-funciones-con-ggplot2/</guid>
      <description>


&lt;p&gt;Cuando tenía la necesidad de graficar una función solía recurrir a programas como &lt;code&gt;MATLAB&lt;/code&gt; o simplemente simulaba algunos datos en &lt;code&gt;R&lt;/code&gt; y lo hacía de la siguiente manera:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)

df &amp;lt;- data.frame( x = rnorm(1000))

g1 &amp;lt;- ggplot(df, aes(x)) +
  geom_density(aes(color = &amp;quot;estimada&amp;quot;), key_glyph = &amp;quot;path&amp;quot;) + theme_classic()
g1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://jgbabativam.rbind.io/post/2020-07-14-gráficas-de-funciones-con-ggplot2/index_files/figure-html/simula-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Hace poco encontré que la versión &lt;code&gt;3.3.2&lt;/code&gt; del paquete &lt;code&gt;ggplot2&lt;/code&gt; permite graficar una función. El usuario puede ingresar la sintaxis de la fórmula o citar el nombre de alguna función de probabilidad conocida. Por ejemplo, en el caso anterior se agregaría la distribución teórica de la siguiente manera&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;g2 &amp;lt;- g1 +
      geom_function(aes(color = &amp;quot;teórica&amp;quot;), fun = dnorm)
g2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://jgbabativam.rbind.io/post/2020-07-14-gráficas-de-funciones-con-ggplot2/index_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Para dar otro ejemplo, considere una distribución chi-cuadrado con 5 grados de libertad, en este caso se establecen los valores para &lt;code&gt;x&lt;/code&gt; en el rango de 0 a 30. Adicionalmente, se debe agregar una tilde (&lt;code&gt;~&lt;/code&gt;) después del igual (&lt;code&gt;=&lt;/code&gt;) y la variable debe estar antecedida por un punto &lt;code&gt;.x&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  xlim(0, 30) +
  geom_function(fun =~ dchisq(.x, df = 5)) + theme_classic()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://jgbabativam.rbind.io/post/2020-07-14-gráficas-de-funciones-con-ggplot2/index_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Finalmente, usted puede escribir la sintaxis de cualquier función, si lo prefiere puede usar directamente la fdp, así:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
   xlim(-3, 3) +
   geom_function(
     aes(color = &amp;quot;Normal&amp;quot;),
     fun =~ 1/sqrt(2 * pi) * exp(-.x^2/2)
     ) +
   geom_function(
     aes(color = &amp;quot;Laplace&amp;quot;),
     fun =~ 1/2 * exp(-abs(.x))
   ) + theme_classic() +
  ylab(&amp;quot;f(x)&amp;quot;) + theme(legend.title = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://jgbabativam.rbind.io/post/2020-07-14-gráficas-de-funciones-con-ggplot2/index_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Por supuesto, puede usarlo en casos que no tienen que ver con probabilidad&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  xlim(-10, 10) +
  geom_function(aes(color = &amp;quot;lineal&amp;quot;),
    fun =~ 3*.x + 1 
    ) +
  geom_function(aes(color = &amp;quot;cuadrática&amp;quot;),
    fun =~ 3*.x^2 + .x + 1             
    ) + ylab(&amp;quot;f(x)&amp;quot;) + theme_classic()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://jgbabativam.rbind.io/post/2020-07-14-gráficas-de-funciones-con-ggplot2/index_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
